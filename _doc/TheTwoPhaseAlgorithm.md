# 两阶段算法

## 0. 译序

内容来源自: http://kociemba.org/cube.htm, 所有图片资源均直接从该处直接复制过来的. 原文是英文, 翻译水平不高, 如有错误, 请指正, 谢谢!

## 1. 前言

下面的文章尝试对[Cube Explorer](http://kociemba.org/cube.htm)中的数学思想和算法进行一些介绍. 

这个过程中我会面临很多问题, 首先, 英语不是我的母语, 所以, 文中的一些描述可能很难甚至无法理解; 其次, 我学习数学已经是很久之前的事了, 所以文章中使用的一些术语显然会是不正确的; 此外, 我只能描述一些核心的思想, 以及编写Cube Explorer所需的内容.

但是, 我依然希望这篇文章会对"两阶段算法"感兴趣或者是想在自己的程序中实现两阶段算法的人有所帮助.

## 2. 置换与面

如果我们观察一个已经还原的魔方, 我们可以看到6*9个面.

![image](./img/cubeclean.gif)

----

如果我们对这个魔方应用一个动作, 面将会被重新排序. 这样的一个重排序, 叫做一个"置换".

我们用6个字母 -- U, R, F, D, B, L 来描述六个顺时针90°的旋转. 我们用形如F2来描述180°旋转, 用形如F'来描述270°(等价于逆时针旋转90°)旋转.

举个例子, 我们执行F动作, 会得到如下结果:

![image](./img/cubef.gif)

----

为了用程序表示这样一个置换, 我们现在只看黄色面. 这里给出了两种表达方式:

1. 移动表示法: F1移动到F3(F1 -> F3), F2 -> F6, F3 -> F9, F4 -> F2, F5 -> F5, F6 -> F8, F7 -> F1, F8 -> F4, F9 -> F7. 可以得到如下表:

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F3|F6|F9|F2|F5|F8|F1|F4|F7

2. 替换表示法: F1位置被F7替换(F1 <- F7), F2 <- F4, F3 <- F1, F4 <- F8, F5 <- F5, F6 <- F2, F7 <- F9, F8 <- F6, F9 <- F3. 可以得到如下表:

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F7|F4|F1|F8|F5|F2|F9|F6|F3

观察上面两个表格, 显然第一行都是一样的, 我们可以略去第一行, 所以, 可以简写为:

* 移动表示法: (F3,F6,F9,F2,F5,F8,F1,F4,F7)
* 替换表示法: (F7,F4,F1,F8,F5,F2,F9,F6,F3)

大多数情况下, 为了直观, 我们不会使用简写形式.

我们用第一种表示方式(移动表示法)来描述面级别的变换, 用第二种方式(替换表示法)表示块级别的变换. 这本章节的剩余部分, 将会使用移动表示法.

----

我们可以定义两个置换的乘积, 例如:

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F2|F1|F6|F3|F5|F4|F8|F7|F9

\*

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F3|F6|F9|F2|F5|F8|F1|F4|F7

=

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F6|F3|F8|F9|F5|F2|F4|F1|F7

> 第一个置换使得 F1 -> F2, 接下来, 第二个置换使得F2 -> F6, 所以两个复合起来, 就是F1 -> F6.

----

置换的乘法与自然数的乘法很相似, 但是, 这里有一个很大的不同之处: 对于自然数的乘法, 3\*5 = 5\*3, 但是对于置换的乘法, 是不满足交换律的:

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F3|F6|F9|F2|F5|F8|F1|F4|F7

\*

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F2|F1|F6|F3|F5|F4|F8|F7|F9

=

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F6|F4|F9|F1|F5|F7|F2|F3|F8

----

还有一个重要的概念, 叫做"逆置换".

观察如下F的置换表示:

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F3|F6|F9|F2|F5|F8|F1|F4|F7

以及另一个置换表示:

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F7|F4|F1|F8|F5|F2|F9|F6|F3

这两个置换相乘的结果是:

F1|F2|F3|F4|F5|F6|F7|F8|F9
-|-|-|-|-|-|-|-|-
F1|F2|F3|F4|F5|F6|F7|F8|F9

这个结果代表着, 什么都不做. 所以当我们用一个置换乘以它的逆置换时, 就会得到"单位置换"(用I表示). 实际上, 在这个例子中, 第二个置换就是F', 所以我们有 F \* F' = I.

你可以尝试一下, 在这种情况下, F' \* F = I也是成立的, 也就是在这种情况下, 乘法满足交换律.

----

在[CubeDefs.htm](http://kociemba.org/math/CubeDefs.htm#faceturns), 你可以看到每一个基本移动的完整定义. 例如:

F = (U1,U2,U3,U4,U5,U6,R1,R4,R7,D3,R2,R3,D2,R5,R6,D1,R8,R9,F3,F6,F9,F2,F5,F8,F1,F4,F7,L3,L6,L9,D4,D5,D6,D7,D8,D9,L1,L2,U9,L4,L5,U8,L7,L8,U7,B1,B2,B3,B4,B5,B6,B7,B8,B9)

> 这里采用的是简写形式

不仅仅移动的动作可以视作是一个个的置换, 每一个打乱的魔方状态也可以看做是置换. 如图:

![image](img/cubescrambled.gif)

从图中可以看出, U1 -> R3, U2 -> L2, U3 -> D3, U4 -> U8, ... , 这个魔方可以表示为: (R3, L2, D3, U8, ...).

当你求解一个魔方时, 实际上, 就是将魔方当前状态的置换表示拆分成一系列基本置换的乘积, 然后求逆置换. 置换乘以逆置换得到单位置换, 这就还原了魔方. Cube Explorer的求解算法就是尝试寻找最短的这个逆置换乘积, 例如图上的状态, 可以在几秒钟, 找到它的逆置换:

```
R2*L*U2*L2*D*R2*U2*L'*D2*R'*U*B*R'*F2*L2*B2*L2*B2
```

但是, 单纯从面级别来表示一个魔方, 还不能高效的还原一个魔方, 这里还有另外的两个级别.

## 块

在块级别上, 我们要描述的置换对象不再是面, 而是针对12个棱块和8个角块.

![image](./img/cubeclean2.gif)

上图中, 标记了UFR角块, DFR角块, FL棱块, UL棱块. 类似地, 角块被命名为: URF, UFL, ULB, UBR, DFR, DLF, DBL, DRB; 棱块命名为: UR, UF, UL, UB, DR, DF, DL, DB, FR, FL, BL, BR.

----

在块级别上, 不能通过简单的置换来描述一个移动或者一个打乱状态, 因为角块可以扭转(旋转120°), 棱块可以翻转.

![image](./img/cubefliptwist.gif)

如图, 块都处在它原有位置, 但是朝向发生了变化. UFL角块发生了顺时针扭转, UBR角块发生了逆时针扭转, DF棱块和FR棱块都被翻转了.

----

如果棱块或者角块不在它原始位置, 可以有很多种方式定义块的朝向. 但是对于两阶段算法, 下面的定义方式是必须的:

![image](./img/cubeoridef.gif)

图中魔方处于还原状态, 有几个面被特殊标记了, 这是用来作为参考朝向的. 如果一个块移动到非原始位置, 该块的参考面与还原状态的一个参考面重合, 我们就定义这个块的朝向为0, 否则, 对于棱块, 就定义朝向为1, 这时我们称这个棱块处于翻转状态; 另外, 角块参考面没有与原始状态的参考面重合, 我们就定义1(顺指针扭转)或者2(逆时针扭转).

在参考框架下, 如果所有棱块和角块的朝向都是0, 这时, 在所有的18中移动方式中, 存在10中移动不会改变棱块和角块的朝向. 这一性质是求解算法的关键.

----

![image](./img/cubeoride1f.gif)

上图中, 魔方经过了一次F移动, 在URF位置处的角块![image](./img/cubie.gif)相对于还原状态下的参考面发生了顺时针扭转, 类似的, DLF位置处的角块和DFR位置处的角块发生了逆时针旋转. 位于UF, DF, FR位置处的棱块发生了翻转.

我们使用"替换表示法"表示块级别的置换. 对于上面的例子: URF被UFL替换(URF <- UFL), UFL‹-DLF, ULB ‹-ULB, UBR‹-UBR, DFR‹-URF, DLF‹-DFR, DBL ‹-DBL, DRB‹-DRB. 如下表:

URL|UFL|ULB|UBR|DFR|DLF|DBL|DRB
-|-|-|-|-|-|-|-
UFL|DLF|ULB|UBR|URF|DFR|DBL|DRB

同时, 我们也需要保留朝向变化的信息, 所以上表需要调整为:

URL|UFL|ULB|UBR|DFR|DLF|DBL|DRB
-|-|-|-|-|-|-|-
c:UFL;o:1|c:DLF;o:2|c:ULB;o:0|c:UBR;o:0|c:URF;o:2|c:DFR;o:1|c:DBL;o:0|c:DRB,o:0

没有扭转, 用0表示; 顺时针扭转, 用1表示; 逆时针扭转用2表示. 通过这种方式, 我们可以很轻松的表示两个朝向的复合. 例如, 我们执行两个逆时针扭转, 结果是2 + 2 = 4, 因为 4 ≡ 1 mod 3, 所以结果是顺时针扭转. 在[CubeDefs.htm](http://kociemba.org/math/CubeDefs.htm#cornfaceturns)中对于基本移动有相关的定义.

对于棱的置换定义也是类似的, 翻转用1表示, 未翻转用0表示.

----

我们需要一个记号来描述置换用来替代上面的表格. 对于F移动, 上面的例子可以写作:

```
F(URF).c = UFL
F(URF).o = 1
F(UFL).c = DLF
F(UFL).o = 2
...
```

----

接下来, 引入R移动来展示F*R是如何工作的.

R = 

URF|UFL|ULB|UBR|DFR|DLF|DBL|DRB
-|-|-|-|-|-|-|-
c:DFR;o:2|c:UFL;o:0|c:ULB;o:0|c:URF;o:1|c:DRB;o:1|c:DLF;o:0|c:DBL;o:0|c:UBR,o:2

![image](./img/Fr.gif)

> 上图是F\*R动作应用到UFL角块上的效果的示意

F动作中F(URF).c = UFL, F(URF).o = 1, 这告诉我们URF位置处的角块会被UFL位置的角块替换掉, 同时移动到URF位置的角块朝向会增加1;

R动作中R(UBR).c = URF, R(UBR).o = 1, 这告诉我们UBR位置处的角块会被URF位置的角块替换掉, 同时移动到UBR位置的角块朝向会增加1.

所以, 当执行F\*R复合动作时, 我们有URF <- UFL, 然后, UBR <- URF. 最终结果是: UBR <- UFL. 这里可以表示为(F\*R)(UBR).c = UFL, 这个表达式的意思是: (F\*R)(UBR).c = F(R(UBR).c).c;

角块朝向的变化不太容易理解. F指示F(URF).o = 1对于URF <- UFL, 意思是, 从UFL位置移动到URF位置的角块, 朝向会增加1. 然后, R移动会导致由URF移动到UBR位置的角块朝向也发生变化, 对于最终移动到UBR位置的角块, 这两个移动的复合变化是F(URF).o+R(UBR).o, 又由于URF = R(UBR).c, 代入之后, 得到: (F\*R)(UBR).o = F(R(UBR).c).o + R(UBR).o.

----

综上, 可以得出形式化的结论, 对于置换A, B, 对于任意位置x处的角块, 我们有:

(A\*B)(x).c = A(B(x).c).c

(A\*B)(x).o = A(B(x).c).o + B(x).o

同样的原则, 对于棱块也适用. 参考[CubeDefs.htm](http://kociemba.org/math/CubeDefs.htm#cornmult)中对于乘法的实现.

当我们需要利用魔方对称的特点时, 我们还需要考虑到动作的镜像的情况, 这时事情会变得有点复杂. 上面描述的对3取余可以理解为C3循环群中的运算, 如果需要考虑镜像的情况, 我们需要使用二面群D3. 这时, 我们引入三个新的数字3, 4, 5来描述.